diff --git a/arch/arm/boot/dts/imx7d-colibri-emmc-eval-v3.dts b/arch/arm/boot/dts/imx7d-colibri-emmc-eval-v3.dts
index 8ee73c870b12..9533b5d59135 100644
--- a/arch/arm/boot/dts/imx7d-colibri-emmc-eval-v3.dts
+++ b/arch/arm/boot/dts/imx7d-colibri-emmc-eval-v3.dts
@@ -11,9 +11,98 @@
 	model = "Toradex Colibri iMX7D 1GB (eMMC) on Colibri Evaluation Board V3";
 	compatible = "toradex,colibri-imx7d-emmc-eval-v3",
 		     "toradex,colibri-imx7d-emmc", "fsl,imx7d";
+	
+	sound_mp {
+		compatible = "simple-audio-card";
+		simple-audio-card,name = "Musica Pristina Digital Output";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,bitclock-master = <&mp_master>;
+		simple-audio-card,frame-master = <&mp_master>;
+		simple-audio-card,cpu {
+			sound-dai = <&sai2>;
+		};
+
+		mp_master: simple-audio-card,codec {
+			sound-dai = <&codec_mp>;
+		};
+	};
+};
+
+/* Kill default sound card. */
+//&codec: sgtl5000@0a {
+&codec {
+	status = "disabled";
 };
 
 &usbotg2 {
 	vbus-supply = <&reg_usbh_vbus>;
 	status = "okay";
 };
+
+&i2c4 {
+	status = "okay";
+	codec_mp: mp_clkgen@75 {
+		compatible = "mp,mp-clkgen";
+		#sound-dai-cells = <0>;
+		reg = <0x75>;
+	};
+	codec_oscsel: mp_oscsel@41 {
+		compatible = "mp,codec-oscsel";
+		mp,clkgen = <&codec_mp>;
+		reg = <0x41>;
+	};
+	codec_aes: mp_aes@20 {
+		compatible = "mp,codec-aes";
+		mp,clkgen = <&codec_mp>;
+		reg = <0x20>;
+	};
+	codec_lcd: mp_lcd@76 {
+		compatible = "mp,codec-lcd";
+		mp,clkgen = <&codec_mp>;
+		reg = <0x76>;
+	};
+};
+
+&sai2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_sai2>;
+	status = "okay";
+};
+
+
+
+/* Disable uart1 since its pins overlap with sai2 pins. */
+// &uart1 {
+// 	status = "disabled";
+// };
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1>;
+	assigned-clocks = <&clks IMX7D_UART1_ROOT_SRC>;
+	assigned-clock-parents = <&clks IMX7D_OSC_24M_CLK>;
+	// uart-has-rtscts; KILL THIS PROPERTY since we are stealing the pins for I2S
+	fsl,dte-mode;
+};
+
+/* Disable uart2 since its pins overlap with sai2 pins. */
+&uart2 {
+	status = "disabled";
+};
+
+&iomuxc {
+	pinctrl_sai2: sai2-grp {
+		fsl,pins = <
+			MX7D_PAD_SAI2_TX_BCLK__SAI2_TX_BCLK		0x1f
+			MX7D_PAD_SAI2_TX_SYNC__SAI2_TX_SYNC		0x1f
+			MX7D_PAD_SAI2_TX_DATA__SAI2_TX_DATA0	0
+		>;
+	};
+
+	pinctrl_uart1: uart1-grp {
+		fsl,pins = <
+			MX7D_PAD_UART1_TX_DATA__UART1_DTE_RX	0x79
+			MX7D_PAD_UART1_RX_DATA__UART1_DTE_TX	0x79
+		>;
+	};
+};
\ No newline at end of file
diff --git a/include/linux/busfreq-imx.h b/include/linux/busfreq-imx.h
new file mode 100644
index 000000000000..46547d0fe7dd
--- /dev/null
+++ b/include/linux/busfreq-imx.h
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2012-2016 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARCH_MXC_BUSFREQ_H__
+#define __ASM_ARCH_MXC_BUSFREQ_H__
+
+#include <linux/notifier.h>
+#include <linux/regulator/consumer.h>
+
+/*
+ * This enumerates busfreq low power mode entry and exit.
+ */
+enum busfreq_event {
+	LOW_BUSFREQ_ENTER,
+	LOW_BUSFREQ_EXIT,
+};
+
+/*
+  * This enumerates the system bus and ddr frequencies in various modes.
+  * BUS_FREQ_HIGH - DDR @ 528MHz, AHB @ 132MHz.
+  * BUS_FREQ_MED - DDR @ 400MHz, AHB @ 132MHz
+  * BUS_FREQ_AUDIO - DDR @ 50MHz/100MHz, AHB @ 24MHz.
+  * BUS_FREQ_LOW  - DDR @ 24MHz, AHB @ 24MHz.
+  * BUS_FREQ_ULTRA_LOW - DDR @ 1MHz, AHB - 3MHz.
+  *
+  * Drivers need to request/release the bus/ddr frequencies based on
+  * their performance requirements. Drivers cannot request/release
+  * BUS_FREQ_ULTRA_LOW mode as this mode is automatically entered from
+  * either BUS_FREQ_AUDIO or BUS_FREQ_LOW
+  * modes.
+  */
+enum bus_freq_mode {
+	BUS_FREQ_HIGH,
+	BUS_FREQ_MED,
+	BUS_FREQ_AUDIO,
+	BUS_FREQ_LOW,
+	BUS_FREQ_ULTRA_LOW,
+};
+
+#if defined(CONFIG_CPU_FREQ) && !defined(CONFIG_ARM64)
+extern struct regulator *arm_reg;
+extern struct regulator *soc_reg;
+void request_bus_freq(enum bus_freq_mode mode);
+void release_bus_freq(enum bus_freq_mode mode);
+int register_busfreq_notifier(struct notifier_block *nb);
+int unregister_busfreq_notifier(struct notifier_block *nb);
+int get_bus_freq_mode(void);
+#elif defined(CONFIG_ARCH_FSL_IMX8MQ)
+void request_bus_freq(enum bus_freq_mode mode);
+void release_bus_freq(enum bus_freq_mode mode);
+int get_bus_freq_mode(void);
+#else
+static inline void request_bus_freq(enum bus_freq_mode mode)
+{
+}
+static inline void release_bus_freq(enum bus_freq_mode mode)
+{
+}
+static inline int register_busfreq_notifier(struct notifier_block *nb)
+{
+	return 0;
+}
+static inline int unregister_busfreq_notifier(struct notifier_block *nb)
+{
+	return 0;
+}
+static inline int get_bus_freq_mode(void)
+{
+	return BUS_FREQ_HIGH;
+}
+#endif
+#endif
\ No newline at end of file
diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 1e9bb1c91770..383e26575344 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -117,6 +117,10 @@ struct snd_pcm_ops {
 #define SNDRV_PCM_RATE_96000		(1<<10)		/* 96000Hz */
 #define SNDRV_PCM_RATE_176400		(1<<11)		/* 176400Hz */
 #define SNDRV_PCM_RATE_192000		(1<<12)		/* 192000Hz */
+#define SNDRV_PCM_RATE_352800		(1<<13)		/* 352800Hz */
+#define SNDRV_PCM_RATE_384000		(1<<14)		/* 384000Hz */
+#define SNDRV_PCM_RATE_705600		(1<<15)		/* 705600Hz */
+#define SNDRV_PCM_RATE_768000		(1<<16)		/* 768000Hz */
 
 #define SNDRV_PCM_RATE_CONTINUOUS	(1<<30)		/* continuous range */
 #define SNDRV_PCM_RATE_KNOT		(1<<31)		/* supports more non-continuos rates */
@@ -129,6 +133,12 @@ struct snd_pcm_ops {
 					 SNDRV_PCM_RATE_88200|SNDRV_PCM_RATE_96000)
 #define SNDRV_PCM_RATE_8000_192000	(SNDRV_PCM_RATE_8000_96000|SNDRV_PCM_RATE_176400|\
 					 SNDRV_PCM_RATE_192000)
+#define SNDRV_PCM_RATE_44100_768000	(SNDRV_PCM_RATE_44100|SNDRV_PCM_RATE_48000|\
+									SNDRV_PCM_RATE_88200|SNDRV_PCM_RATE_96000|\
+									SNDRV_PCM_RATE_176400|SNDRV_PCM_RATE_192000|\
+									SNDRV_PCM_RATE_352800|SNDRV_PCM_RATE_384000|\
+									SNDRV_PCM_RATE_705600|SNDRV_PCM_RATE_768000)
+					 
 #define _SNDRV_PCM_FMTBIT(fmt)		(1ULL << (__force int)SNDRV_PCM_FORMAT_##fmt)
 #define SNDRV_PCM_FMTBIT_S8		_SNDRV_PCM_FMTBIT(S8)
 #define SNDRV_PCM_FMTBIT_U8		_SNDRV_PCM_FMTBIT(U8)
diff --git a/patch.diff b/patch.diff
new file mode 100644
index 000000000000..ae1c5dde87fa
--- /dev/null
+++ b/patch.diff
@@ -0,0 +1,104 @@
+diff --git a/arch/arm/boot/dts/imx7d-colibri-emmc-eval-v3.dts b/arch/arm/boot/dts/imx7d-colibri-emmc-eval-v3.dts
+index 8ee73c870b12..9533b5d59135 100644
+--- a/arch/arm/boot/dts/imx7d-colibri-emmc-eval-v3.dts
++++ b/arch/arm/boot/dts/imx7d-colibri-emmc-eval-v3.dts
+@@ -11,9 +11,98 @@
+ 	model = "Toradex Colibri iMX7D 1GB (eMMC) on Colibri Evaluation Board V3";
+ 	compatible = "toradex,colibri-imx7d-emmc-eval-v3",
+ 		     "toradex,colibri-imx7d-emmc", "fsl,imx7d";
++	
++	sound_mp {
++		compatible = "simple-audio-card";
++		simple-audio-card,name = "Musica Pristina Digital Output";
++		simple-audio-card,format = "i2s";
++		simple-audio-card,bitclock-master = <&mp_master>;
++		simple-audio-card,frame-master = <&mp_master>;
++		simple-audio-card,cpu {
++			sound-dai = <&sai2>;
++		};
++
++		mp_master: simple-audio-card,codec {
++			sound-dai = <&codec_mp>;
++		};
++	};
++};
++
++/* Kill default sound card. */
++//&codec: sgtl5000@0a {
++&codec {
++	status = "disabled";
+ };
+ 
+ &usbotg2 {
+ 	vbus-supply = <&reg_usbh_vbus>;
+ 	status = "okay";
+ };
++
++&i2c4 {
++	status = "okay";
++	codec_mp: mp_clkgen@75 {
++		compatible = "mp,mp-clkgen";
++		#sound-dai-cells = <0>;
++		reg = <0x75>;
++	};
++	codec_oscsel: mp_oscsel@41 {
++		compatible = "mp,codec-oscsel";
++		mp,clkgen = <&codec_mp>;
++		reg = <0x41>;
++	};
++	codec_aes: mp_aes@20 {
++		compatible = "mp,codec-aes";
++		mp,clkgen = <&codec_mp>;
++		reg = <0x20>;
++	};
++	codec_lcd: mp_lcd@76 {
++		compatible = "mp,codec-lcd";
++		mp,clkgen = <&codec_mp>;
++		reg = <0x76>;
++	};
++};
++
++&sai2 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&pinctrl_sai2>;
++	status = "okay";
++};
++
++
++
++/* Disable uart1 since its pins overlap with sai2 pins. */
++// &uart1 {
++// 	status = "disabled";
++// };
++
++&uart1 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&pinctrl_uart1>;
++	assigned-clocks = <&clks IMX7D_UART1_ROOT_SRC>;
++	assigned-clock-parents = <&clks IMX7D_OSC_24M_CLK>;
++	// uart-has-rtscts; KILL THIS PROPERTY since we are stealing the pins for I2S
++	fsl,dte-mode;
++};
++
++/* Disable uart2 since its pins overlap with sai2 pins. */
++&uart2 {
++	status = "disabled";
++};
++
++&iomuxc {
++	pinctrl_sai2: sai2-grp {
++		fsl,pins = <
++			MX7D_PAD_SAI2_TX_BCLK__SAI2_TX_BCLK		0x1f
++			MX7D_PAD_SAI2_TX_SYNC__SAI2_TX_SYNC		0x1f
++			MX7D_PAD_SAI2_TX_DATA__SAI2_TX_DATA0	0
++		>;
++	};
++
++	pinctrl_uart1: uart1-grp {
++		fsl,pins = <
++			MX7D_PAD_UART1_TX_DATA__UART1_DTE_RX	0x79
++			MX7D_PAD_UART1_RX_DATA__UART1_DTE_TX	0x79
++		>;
++	};
++};
+\ No newline at end of file
diff --git a/sound/core/pcm_native.c b/sound/core/pcm_native.c
index 860543a4c840..c9905aa5ac07 100644
--- a/sound/core/pcm_native.c
+++ b/sound/core/pcm_native.c
@@ -2162,13 +2162,14 @@ static int snd_pcm_hw_rule_sample_bits(struct snd_pcm_hw_params *params,
 	return snd_interval_refine(hw_param_interval(params, rule->var), &t);
 }
 
-#if SNDRV_PCM_RATE_5512 != 1 << 0 || SNDRV_PCM_RATE_192000 != 1 << 12
+#if SNDRV_PCM_RATE_5512 != 1 << 0 || SNDRV_PCM_RATE_768000 != 1 << 16
 #error "Change this table"
 #endif
 
 static const unsigned int rates[] = {
 	5512, 8000, 11025, 16000, 22050, 32000, 44100,
-	48000, 64000, 88200, 96000, 176400, 192000
+	48000, 64000, 88200, 96000, 176400, 192000,
+	352800, 384000, 705600, 768000
 };
 
 const struct snd_pcm_hw_constraint_list snd_pcm_known_rates = {
diff --git a/sound/soc/fsl/fsl_dsd.h b/sound/soc/fsl/fsl_dsd.h
new file mode 100644
index 000000000000..448afe431f10
--- /dev/null
+++ b/sound/soc/fsl/fsl_dsd.h
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __FSL_DSD_H
+#define __FSL_DSD_H
+
+#include <linux/pinctrl/consumer.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+static bool fsl_is_dsd(struct snd_pcm_hw_params *params)
+{
+	snd_pcm_format_t format = params_format(params);
+
+	switch (format) {
+	case SNDRV_PCM_FORMAT_DSD_U8:
+	case SNDRV_PCM_FORMAT_DSD_U16_LE:
+	case SNDRV_PCM_FORMAT_DSD_U16_BE:
+	case SNDRV_PCM_FORMAT_DSD_U32_LE:
+	case SNDRV_PCM_FORMAT_DSD_U32_BE:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static inline struct pinctrl_state *fsl_get_pins_state(struct pinctrl *pinctrl,
+	struct snd_pcm_hw_params *params, u32 bclk)
+{
+	struct pinctrl_state *state = 0;
+
+	if (fsl_is_dsd(params)) {
+		/* DSD512@44.1kHz, DSD512@48kHz */
+		if (bclk >= 22579200)
+			state = pinctrl_lookup_state(pinctrl, "dsd512");
+
+		/* Get default DSD state */
+		if (IS_ERR_OR_NULL(state))
+			state = pinctrl_lookup_state(pinctrl, "dsd");
+	} else {
+		/* 706k32b2c, 768k32b2c, etc */
+		if (bclk >= 45158400)
+			state = pinctrl_lookup_state(pinctrl, "pcm_b2m");
+	}
+
+	/* Get default state */
+	if (IS_ERR_OR_NULL(state))
+		state = pinctrl_lookup_state(pinctrl, "default");
+
+	return state;
+}
+
+#endif /* __FSL_DSD_H */
\ No newline at end of file
diff --git a/sound/soc/fsl/fsl_sai.c b/sound/soc/fsl/fsl_sai.c
index 8593269156bd..0fbfc62293e2 100644
--- a/sound/soc/fsl/fsl_sai.c
+++ b/sound/soc/fsl/fsl_sai.c
@@ -28,7 +28,8 @@
 static const unsigned int fsl_sai_rates[] = {
 	8000, 11025, 12000, 16000, 22050,
 	24000, 32000, 44100, 48000, 64000,
-	88200, 96000, 176400, 192000
+	88200, 96000, 176400, 192000,
+	352800, 384000, 705600, 768000
 };
 
 static const struct snd_pcm_hw_constraint_list fsl_sai_rate_constraints = {
@@ -594,6 +595,7 @@ static int fsl_sai_trigger(struct snd_pcm_substream *substream, int cmd,
 static int fsl_sai_startup(struct snd_pcm_substream *substream,
 		struct snd_soc_dai *cpu_dai)
 {
+	pr_warn("************   fsl_sai_startup");
 	struct fsl_sai *sai = snd_soc_dai_get_drvdata(cpu_dai);
 	bool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
 	struct device *dev = &sai->pdev->dev;
diff --git a/sound/soc/fsl/fsl_sai.h b/sound/soc/fsl/fsl_sai.h
index 24cb156bf995..27c1dff90585 100644
--- a/sound/soc/fsl/fsl_sai.h
+++ b/sound/soc/fsl/fsl_sai.h
@@ -1,50 +1,99 @@
-/* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright 2012-2013 Freescale Semiconductor, Inc.
+ * Copyright 2012-2016 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
  */
 
 #ifndef __FSL_SAI_H
 #define __FSL_SAI_H
 
+#include <linux/pm_qos.h>
 #include <sound/dmaengine_pcm.h>
 
 #define FSL_SAI_FORMATS (SNDRV_PCM_FMTBIT_S16_LE |\
-			 SNDRV_PCM_FMTBIT_S20_3LE |\
 			 SNDRV_PCM_FMTBIT_S24_LE |\
-			 SNDRV_PCM_FMTBIT_S32_LE)
+			 SNDRV_PCM_FMTBIT_S32_LE |\
+			 SNDRV_PCM_FMTBIT_DSD_U8 |\
+			 SNDRV_PCM_FMTBIT_DSD_U16_LE |\
+			 SNDRV_PCM_FMTBIT_DSD_U32_LE)
 
 /* SAI Register Map Register */
-#define FSL_SAI_TCSR	0x00 /* SAI Transmit Control */
-#define FSL_SAI_TCR1	0x04 /* SAI Transmit Configuration 1 */
-#define FSL_SAI_TCR2	0x08 /* SAI Transmit Configuration 2 */
-#define FSL_SAI_TCR3	0x0c /* SAI Transmit Configuration 3 */
-#define FSL_SAI_TCR4	0x10 /* SAI Transmit Configuration 4 */
-#define FSL_SAI_TCR5	0x14 /* SAI Transmit Configuration 5 */
-#define FSL_SAI_TDR	0x20 /* SAI Transmit Data */
-#define FSL_SAI_TFR	0x40 /* SAI Transmit FIFO */
+#define FSL_SAI_VERID	0x00 /* SAI Version ID Register */
+#define FSL_SAI_PARAM	0x04 /* SAI Parameter Register */
+#define FSL_SAI_TCSR(offset) (0x00 + offset) /* SAI Transmit Control */
+#define FSL_SAI_TCR1(offset) (0x04 + offset) /* SAI Transmit Configuration 1 */
+#define FSL_SAI_TCR2(offset) (0x08 + offset) /* SAI Transmit Configuration 2 */
+#define FSL_SAI_TCR3(offset) (0x0c + offset) /* SAI Transmit Configuration 3 */
+#define FSL_SAI_TCR4(offset) (0x10 + offset) /* SAI Transmit Configuration 4 */
+#define FSL_SAI_TCR5(offset) (0x14 + offset) /* SAI Transmit Configuration 5 */
+#define FSL_SAI_TDR0    0x20 /* SAI Transmit Data */
+#define FSL_SAI_TDR1    0x24 /* SAI Transmit Data */
+#define FSL_SAI_TDR2    0x28 /* SAI Transmit Data */
+#define FSL_SAI_TDR3    0x2C /* SAI Transmit Data */
+#define FSL_SAI_TDR4    0x30 /* SAI Transmit Data */
+#define FSL_SAI_TDR5    0x34 /* SAI Transmit Data */
+#define FSL_SAI_TDR6    0x38 /* SAI Transmit Data */
+#define FSL_SAI_TDR7    0x3C /* SAI Transmit Data */
+#define FSL_SAI_TFR0    0x40 /* SAI Transmit FIFO */
+#define FSL_SAI_TFR1    0x44 /* SAI Transmit FIFO */
+#define FSL_SAI_TFR2    0x48 /* SAI Transmit FIFO */
+#define FSL_SAI_TFR3    0x4C /* SAI Transmit FIFO */
+#define FSL_SAI_TFR4    0x50 /* SAI Transmit FIFO */
+#define FSL_SAI_TFR5    0x54 /* SAI Transmit FIFO */
+#define FSL_SAI_TFR6    0x58 /* SAI Transmit FIFO */
+#define FSL_SAI_TFR7    0x5C /* SAI Transmit FIFO */
 #define FSL_SAI_TMR	0x60 /* SAI Transmit Mask */
-#define FSL_SAI_RCSR	0x80 /* SAI Receive Control */
-#define FSL_SAI_RCR1	0x84 /* SAI Receive Configuration 1 */
-#define FSL_SAI_RCR2	0x88 /* SAI Receive Configuration 2 */
-#define FSL_SAI_RCR3	0x8c /* SAI Receive Configuration 3 */
-#define FSL_SAI_RCR4	0x90 /* SAI Receive Configuration 4 */
-#define FSL_SAI_RCR5	0x94 /* SAI Receive Configuration 5 */
-#define FSL_SAI_RDR	0xa0 /* SAI Receive Data */
-#define FSL_SAI_RFR	0xc0 /* SAI Receive FIFO */
+#define FSL_SAI_TTCTL	0x70 /* SAI Transmit Timestamp Control Register */
+#define FSL_SAI_TTCTN	0x74 /* SAI Transmit Timestamp Counter Register */
+#define FSL_SAI_TBCTN	0x78 /* SAI Transmit Bit Counter Register */
+#define FSL_SAI_TTCAP	0x7C /* SAI Transmit Timestamp Capture */
+
+#define FSL_SAI_RCSR(offset) (0x80 + offset) /* SAI Receive Control */
+#define FSL_SAI_RCR1(offset) (0x84 + offset) /* SAI Receive Configuration 1 */
+#define FSL_SAI_RCR2(offset) (0x88 + offset) /* SAI Receive Configuration 2 */
+#define FSL_SAI_RCR3(offset) (0x8c + offset) /* SAI Receive Configuration 3 */
+#define FSL_SAI_RCR4(offset) (0x90 + offset) /* SAI Receive Configuration 4 */
+#define FSL_SAI_RCR5(offset) (0x94 + offset) /* SAI Receive Configuration 5 */
+#define FSL_SAI_RDR0    0xa0 /* SAI Receive Data */
+#define FSL_SAI_RDR1    0xa4 /* SAI Receive Data */
+#define FSL_SAI_RDR2    0xa8 /* SAI Receive Data */
+#define FSL_SAI_RDR3    0xac /* SAI Receive Data */
+#define FSL_SAI_RDR4    0xb0 /* SAI Receive Data */
+#define FSL_SAI_RDR5    0xb4 /* SAI Receive Data */
+#define FSL_SAI_RDR6    0xb8 /* SAI Receive Data */
+#define FSL_SAI_RDR7    0xbc /* SAI Receive Data */
+#define FSL_SAI_RFR0    0xc0 /* SAI Receive FIFO */
+#define FSL_SAI_RFR1    0xc4 /* SAI Receive FIFO */
+#define FSL_SAI_RFR2    0xc8 /* SAI Receive FIFO */
+#define FSL_SAI_RFR3    0xcc /* SAI Receive FIFO */
+#define FSL_SAI_RFR4    0xd0 /* SAI Receive FIFO */
+#define FSL_SAI_RFR5    0xd4 /* SAI Receive FIFO */
+#define FSL_SAI_RFR6    0xd8 /* SAI Receive FIFO */
+#define FSL_SAI_RFR7    0xdc /* SAI Receive FIFO */
 #define FSL_SAI_RMR	0xe0 /* SAI Receive Mask */
+#define FSL_SAI_RTCTL	0xf0 /* SAI Receive Timestamp Control Register */
+#define FSL_SAI_RTCTN	0xf4 /* SAI Receive Timestamp Counter Register */
+#define FSL_SAI_RBCTN	0xf8 /* SAI Receive Bit Counter Register */
+#define FSL_SAI_RTCAP	0xfc /* SAI Receive Timestamp Capture */
+
+#define FSL_SAI_MCTL	0x100 /* SAI MCLK Control Register */
+#define FSL_SAI_MDIV	0x104 /* SAI MCLK Divide Register */
 
-#define FSL_SAI_xCSR(tx)	(tx ? FSL_SAI_TCSR : FSL_SAI_RCSR)
-#define FSL_SAI_xCR1(tx)	(tx ? FSL_SAI_TCR1 : FSL_SAI_RCR1)
-#define FSL_SAI_xCR2(tx)	(tx ? FSL_SAI_TCR2 : FSL_SAI_RCR2)
-#define FSL_SAI_xCR3(tx)	(tx ? FSL_SAI_TCR3 : FSL_SAI_RCR3)
-#define FSL_SAI_xCR4(tx)	(tx ? FSL_SAI_TCR4 : FSL_SAI_RCR4)
-#define FSL_SAI_xCR5(tx)	(tx ? FSL_SAI_TCR5 : FSL_SAI_RCR5)
+#define FSL_SAI_xCSR(tx, off)	(tx ? FSL_SAI_TCSR(off) : FSL_SAI_RCSR(off))
+#define FSL_SAI_xCR1(tx, off)	(tx ? FSL_SAI_TCR1(off) : FSL_SAI_RCR1(off))
+#define FSL_SAI_xCR2(tx, off)	(tx ? FSL_SAI_TCR2(off) : FSL_SAI_RCR2(off))
+#define FSL_SAI_xCR3(tx, off)	(tx ? FSL_SAI_TCR3(off) : FSL_SAI_RCR3(off))
+#define FSL_SAI_xCR4(tx, off)	(tx ? FSL_SAI_TCR4(off) : FSL_SAI_RCR4(off))
+#define FSL_SAI_xCR5(tx, off)	(tx ? FSL_SAI_TCR5(off) : FSL_SAI_RCR5(off))
 #define FSL_SAI_xDR(tx)		(tx ? FSL_SAI_TDR : FSL_SAI_RDR)
 #define FSL_SAI_xFR(tx)		(tx ? FSL_SAI_TFR : FSL_SAI_RFR)
 #define FSL_SAI_xMR(tx)		(tx ? FSL_SAI_TMR : FSL_SAI_RMR)
 
 /* SAI Transmit/Receive Control Register */
 #define FSL_SAI_CSR_TERE	BIT(31)
+#define FSL_SAI_CSR_SE		BIT(30)
 #define FSL_SAI_CSR_FR		BIT(25)
 #define FSL_SAI_CSR_SR		BIT(24)
 #define FSL_SAI_CSR_xF_SHIFT	16
@@ -78,18 +127,29 @@
 #define FSL_SAI_CR2_MSEL(ID)	((ID) << 26)
 #define FSL_SAI_CR2_BCP		BIT(25)
 #define FSL_SAI_CR2_BCD_MSTR	BIT(24)
+#define FSL_SAI_CR2_BYP		BIT(23) /* BCLK bypass */
 #define FSL_SAI_CR2_DIV_MASK	0xff
 
 /* SAI Transmit and Receive Configuration 3 Register */
-#define FSL_SAI_CR3_TRCE	BIT(16)
+#define FSL_SAI_CR3_TRCE_MASK	(0xff << 16)
+#define FSL_SAI_CR3_TRCE(x)	(x << 16)
 #define FSL_SAI_CR3_WDFL(x)	(x)
 #define FSL_SAI_CR3_WDFL_MASK	0x1f
 
 /* SAI Transmit and Receive Configuration 4 Register */
+
+#define FSL_SAI_CR4_FCONT	BIT(28)
+#define FSL_SAI_CR4_FCOMB_SHIFT BIT(26)
+#define FSL_SAI_CR4_FCOMB_SOFT  BIT(27)
+#define FSL_SAI_CR4_FCOMB_MASK  (0x3 << 26)
+#define FSL_SAI_CR4_FPACK_8     (0x2 << 24)
+#define FSL_SAI_CR4_FPACK_16    (0x3 << 24)
 #define FSL_SAI_CR4_FRSZ(x)	(((x) - 1) << 16)
 #define FSL_SAI_CR4_FRSZ_MASK	(0x1f << 16)
 #define FSL_SAI_CR4_SYWD(x)	(((x) - 1) << 8)
 #define FSL_SAI_CR4_SYWD_MASK	(0x1f << 8)
+#define FSL_SAI_CR4_CHMOD	(1 << 5)
+#define FSL_SAI_CR4_CHMOD_MASK	(1 << 5)
 #define FSL_SAI_CR4_MF		BIT(4)
 #define FSL_SAI_CR4_FSE		BIT(3)
 #define FSL_SAI_CR4_FSP		BIT(1)
@@ -103,6 +163,33 @@
 #define FSL_SAI_CR5_FBT(x)	((x) << 8)
 #define FSL_SAI_CR5_FBT_MASK	(0x1f << 8)
 
+/* SAI MCLK Control Register */
+#define FSL_SAI_MCTL_MCLK_EN	BIT(30)	/* MCLK Enable */
+#define FSL_SAI_MCTL_MSEL_MASK	(0x3 << 24)
+#define FSL_SAI_MCTL_MSEL(ID)   ((ID) << 24)
+#define FSL_SAI_MCTL_MSEL_BUS	0
+#define FSL_SAI_MCTL_MSEL_MCLK1	BIT(24)
+#define FSL_SAI_MCTL_MSEL_MCLK2	BIT(25)
+#define FSL_SAI_MCTL_MSEL_MCLK3	(BIT(24) | BIT(25))
+#define FSL_SAI_MCTL_DIV_EN	BIT(23)
+#define FSL_SAI_MCTL_DIV_MASK	0xFF
+
+/* SAI VERID Register */
+#define FSL_SAI_VER_ID_SHIFT	16
+#define FSL_SAI_VER_ID_MASK	(0xFFFF << FSL_SAI_VER_ID_SHIFT)
+#define FSL_SAI_VER_EFIFO_EN	BIT(0)
+#define FSL_SAI_VER_TSTMP_EN	BIT(1)
+
+/* SAI PARAM Register */
+#define FSL_SAI_PAR_SPF_SHIFT	16
+#define FSL_SAI_PAR_SPF_MASK	(0x0F << FSL_SAI_PAR_SPF_SHIFT)
+#define FSL_SAI_PAR_WPF_SHIFT	8
+#define FSL_SAI_PAR_WPF_MASK	(0x0F << FSL_SAI_PAR_WPF_SHIFT)
+#define FSL_SAI_PAR_DLN_MASK	(0x0F)
+
+/* SAI MCLK Divide Register */
+#define FSL_SAI_MDIV_MASK	0xFFFFF
+
 /* SAI type */
 #define FSL_SAI_DMA		BIT(0)
 #define FSL_SAI_USE_AC97	BIT(1)
@@ -126,28 +213,79 @@
 #define FSL_SAI_MAXBURST_TX 6
 #define FSL_SAI_MAXBURST_RX 6
 
+#define SAI_FLAG_PMQOS   BIT(0)
+
+struct fsl_sai_soc_data {
+	unsigned int fifo_depth;
+	unsigned int fifos;
+	unsigned int dataline;
+	unsigned int flags;
+	unsigned char reg_offset;
+	bool imx;
+	/* True for EDMA because it needs period size multiple of maxburst */
+	bool constrain_period_size;
+};
+
+struct fsl_sai_verid {
+	u32 id;
+	bool timestamp_en;
+	bool extfifo_en;
+	bool loaded;
+};
+
+struct fsl_sai_param {
+	u32 spf; /* max slots per frame */
+	u32 wpf; /* words in fifo */
+	u32 dln; /* number of datalines implemented */
+};
+
+struct fsl_sai_dl_cfg {
+	unsigned int pins;
+	unsigned int mask[2];
+	unsigned int offset[2];
+};
+
 struct fsl_sai {
 	struct platform_device *pdev;
 	struct regmap *regmap;
 	struct clk *bus_clk;
 	struct clk *mclk_clk[FSL_SAI_MCLK_MAX];
+	struct clk *pll8k_clk;
+	struct clk *pll11k_clk;
 
-	bool is_slave_mode;
+	bool slave_mode[2];
 	bool is_lsb_first;
 	bool is_dsp_mode;
-	bool sai_on_imx;
+	bool is_multi_lane;
 	bool synchronous[2];
+	bool is_stream_opened[2];
+	bool is_dsd;
+
+	int pcm_dl_cfg_cnt;
+	int dsd_dl_cfg_cnt;
+	struct fsl_sai_dl_cfg *pcm_dl_cfg;
+	struct fsl_sai_dl_cfg *dsd_dl_cfg;
+
+	unsigned int masterflag[2];
 
 	unsigned int mclk_id[2];
 	unsigned int mclk_streams;
 	unsigned int slots;
 	unsigned int slot_width;
+	unsigned int bitclk_ratio;
 
 	struct snd_dmaengine_dai_dma_data dma_params_rx;
 	struct snd_dmaengine_dai_dma_data dma_params_tx;
+	const struct fsl_sai_soc_data *soc;
+	struct pm_qos_request pm_qos_req;
+	struct pinctrl *pinctrl;
+	struct pinctrl_state *pins_state;
+
+	struct fsl_sai_verid verid;
+	struct fsl_sai_param param;
 };
 
 #define TX 1
 #define RX 0
 
-#endif /* __FSL_SAI_H */
+#endif /* __FSL_SAI_H */
\ No newline at end of file
diff --git a/sound/soc/fsl/imx-pcm.h b/sound/soc/fsl/imx-pcm.h
index 5dd406774d3e..18eea78d3981 100644
--- a/sound/soc/fsl/imx-pcm.h
+++ b/sound/soc/fsl/imx-pcm.h
@@ -1,9 +1,13 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
 /*
  * Copyright 2009 Sascha Hauer <s.hauer@pengutronix.de>
  *
  * This code is based on code copyrighted by Freescale,
  * Liam Girdwood, Javier Martin and probably others.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
  */
 
 #ifndef _IMX_PCM_H
@@ -39,13 +43,27 @@ struct imx_pcm_fiq_params {
 	struct snd_dmaengine_dai_dma_data *dma_params_tx;
 };
 
+#if IS_ENABLED(CONFIG_SND_SOC_IMX_PCM_RPMSG)
+int imx_rpmsg_platform_register(struct device *dev);
+#else
+static inline int imx_rpmsg_platform_register(struct device *dev)
+{
+	return -ENODEV;
+}
+#endif
+
 #if IS_ENABLED(CONFIG_SND_SOC_IMX_PCM_DMA)
 int imx_pcm_dma_init(struct platform_device *pdev, size_t size);
+int imx_pcm_platform_register(struct device *dev);
 #else
 static inline int imx_pcm_dma_init(struct platform_device *pdev, size_t size)
 {
 	return -ENODEV;
 }
+static inline int imx_pcm_platform_register(struct device *dev)
+{
+	return -ENODEV;
+}
 #endif
 
 #if IS_ENABLED(CONFIG_SND_SOC_IMX_PCM_FIQ)
@@ -64,4 +82,39 @@ static inline void imx_pcm_fiq_exit(struct platform_device *pdev)
 }
 #endif
 
-#endif /* _IMX_PCM_H */
+static inline void imx_pcm_stream_trigger(struct snd_pcm_substream *s, int tr)
+{
+	if (s->runtime->status->state == SNDRV_PCM_STATE_RUNNING && s->ops)
+		s->ops->trigger(s, tr);
+}
+
+static inline void imx_stop_lock_pcm_streams(struct snd_pcm_substream **s,
+					     int count, unsigned long *flags)
+{
+	int i;
+
+	local_irq_save(*flags);
+	for (i = 0; i < count; i++) {
+		if (!s[i])
+			continue;
+		snd_pcm_stream_lock(s[i]);
+		imx_pcm_stream_trigger(s[i], SNDRV_PCM_TRIGGER_STOP);
+	}
+}
+
+static inline void imx_start_unlock_pcm_streams(struct snd_pcm_substream **s,
+						int count, unsigned long *flags)
+{
+	int i;
+
+	for (i = count - 1; i >= 0; i--) {
+		if (!s[i])
+			continue;
+		imx_pcm_stream_trigger(s[i], SNDRV_PCM_TRIGGER_START);
+		snd_pcm_stream_unlock(s[i]);
+	}
+	local_irq_restore(*flags);
+}
+
+
+#endif /* _IMX_PCM_H */
\ No newline at end of file
